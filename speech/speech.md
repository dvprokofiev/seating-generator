# Создание веб-сайта для нахождения оптимальной рассадки учеников в классе

Даниил Прокофьев <d@dvprokofiev.ru> Этот документ доступен по лицензии
[CC-BY-SA 4.0](https://creativecommons.org/licenses/by-sa/4.0/deed.ru).

![](https://mirrors.creativecommons.org/presskit/buttons/88x31/png/by-sa.png){width="1.3433333333333333in" height="0.47in"}

## Вступление. Пределы человеческого мозга

Идея появилось у меня в тот момент, когда я подумал, как сложно может
быть рассадить учеников в классе так, чтобы никто никому не мешал, никто
никого не отвлекал, друзья сидели вместе, а я со своим испорченным
зрением сидел не дальше третьей парты на среднем ряду.

Но человеку доверять такую задачу - неэффективно, ведь человеческий мозг
способен в момент времени удерживать не более $7 \pm 2$ факторов (это
так называемое число Миллера). В то время как при рассадке класса в 30
человек со своими предпочтениями, медицинскими ограничениями, друзьями…
Это сотни перекрестных ограничений, которые трудно учесть.

Поэтому разумно будет поручить эту задачу компьютеру, для которого
решить подобную многокритериальную задачу нахождения рассадки - не
проблема.

## Постановка задачи

Разработать веб-сайт, генерирующий оптимальную рассадку с учетом
заданных ограничений и предпочтений

#### Какие могут ограничения и предпочтения?

Мне не хотелось ограничивать свободу учителя и усложнять себе жизнь в
случае, если когда-нибудь понадобиться расширить функционал генератора,
вводя рассадку по оценкам или среднему баллу, или по росту. Поэтому я
выделил четыре типа ограничений:

- Ограничения, связанные с **медицинскими предписаниями** (например,
  ученик должен сидеть за первой партой согласно предписанию врача)

- Ограничения, связанные с **нежелательным соседством** двух учеников
  (например, двое учеников враждуют)

- Предпочтения по **рядам и партам** (например, ученик хочет сидеть на
  первой парте)

- Предпочтения учеников по **соседству** (например, двое друзей хотят
  сидеть вместе)

Задача относится к NP-полным задачам. (задачи, для которого не
существует известного алгоритма, работающего за полиноминальное время,
но правильность ответа которой можно проверить за полиноминальное
время). Значит, для решения этой задачи будет хорошо использовать
эвристику - алгоритм решения задачи, включающий практический метод, не
являющийся гарантированно точным или оптимальным, но достаточный для
решения поставленной задачи.

## Жадность

Для решения задачи можно попробовать использовать алгоритм, который мне
кажется самым удобным при ручной рассадке учеников. В чем его суть?

- Выставим учеников в очередь. Сначала поставим тех, кто имеет
  медицинские, потом тех, кто имеет просто предпочтения по ряду или
  парте, потом тех, кому вместе сидеть нельзя и, наконец друзей
  (порядок предпочтений можно менять)

- Возьмем одного ученика из очереди и посадим его на лучшее в данный
  момент для него место

Казалось бы, что может пойти не так? Но нет. Посаженный на первых порах
неудачно, ученик будет мешать возникновению оптимальной рассадки.
Алгоритм может и найдет какое-то решение, и что-то в нем будет хорошего,
но это будет локальный максимум, а не глобальный, который мы ищем.

## Метод отжига

Процесс отжига в физике — это когда металл сначала сильно нагревают, а
потом медленно снижают его температуру. Идея в том, чтобы выстроить
атомы в кристаллическую решётку и сформировать как можно больше таких
устойчивых решёток в металле. Если всё сделать правильно, у металла
снижается твёрдость, убираются внутренние напряжения и металл становится
более однородным — так его легче обрабатывать.

Если выписать из процесса отжига ключевые мысли и точки, то получим
интересное:

- есть система, которая находится не в нужном для нас состоянии

- есть процессы, которые могут протекать в этой системе

- есть параметр (температура), благодаря которому система сама может
  отрегулировать себя и прийти в нужное состояние

- и есть конечное значение (температуры), по достижении которого
  система считается максимально близкой к нужному состоянию

Однако сам алгоритм довольно медленный, так как для получения
оптимального результата требует медленного охлаждения. А при быстром
охлаждении алгоритм все так же может застревать в локальном максимуме.

## Генетический алгоритм

Обратимся к другому алгоритму - генетическому. Будем развивать не одно
решение, а целую популяцию, и будем производить над ней такие операции
как естественный отбор, скрещивание, случайная мутация.

Однако в данном случае эволюция получается слепая. То есть мутации
часты, но случайны, и на то, чтобы переместить двух учеников местами,
алгоритму может потребоваться очень много поколений, что не есть хорошо.

## Меметический алгоритм

Поэтому в дополнение к генетике будем к каждой из лучшей особей и с
шансом 5% к случайной особи применять локальный поиск.

#### Что такое локальный поиск?

В моей реализации локальный поиск N раз берет двух случайных учеников и
меняет их местами. Если результат стал лучше, то мы оставляем их так.
Если нет, то возвращаем на место.

Несмотря на то, что алгоритм примитивный, его внедрение помогло снизить
количество поколений, необходимых для получения оптимальной рассадки и
тем самым снизить время выполнения.

## Как хранить рассадки в памяти?

Использовать одномерные массивы, поскольку с ними любые операции
производить гораздо легче. Однако возникает проблема - если учеников в
классе меньше чем мест, то для того, чтобы ученик мог занять любое место
в классе необходимо, чтобы одномерный массив был размера большего, чем
количество учеников.

Каждому ученику присваивается номер от 1 до n (количества учеников).
Все, что больше n, считается как пустое место.

## Как работает меметический алгоритм?

Рассмотрим сам цикл популяций.

1.  Идем по поколениям. Даем огромный “кредит”:
    $$Generations = min(300 + 20 \cdot n,2500)$$

2.  Оценим каждую особь с помощью функции fitness()

3.  Найдем индекс лучшей рассадки в scores

4.  Проверяем для предотвращения стагнации - если за последние поколение
    результат не улучшился более чем на 0.001, прибавляем 1 к
    stagnationCounter

5.  Если stagnationCounter \>= stagnationLimit (максимального количества
    поколений, в течение которых позволено оценке лучшей рассадки не
    меняться достаточно сильно в лучшую сторону), то прерываем
    программу.

6.  Встряхиваем популяцию, если алгоритм близок к стагнации

7.  Копируем лучшую особь в новую популяцию и применяем к ней локальный
    поиск (элитизм)

8.  С помощью турнира (отбирая две случайные особи) и их скрещиваем

9.  С небольшим шансом в получившемся потомке меняем двух учеников
    случайным образом

## Фитнес функция: как оценить рассадку?

Оценка рассадки есть сумма удовлетворенности каждого из учеников. Стоит
заметить, что для проверки предпочтений (медицинских и просто по рядам и
партам) используется такая технология: при запуске алгоритма мы
генерируем массив, который для каждого ученика и его возможного места
сразу заполняет количество баллов, которые он может получить. Это
позволяет нам быстро (за константу) считать, насколько учтены данные
предпочтения.

## Как работает проверка предпочтений?

Каждая функция проверки того или иного критерия возвращает
нормализованное значение от 0 до 1. Оно считается так:

утченность_предпочтения / максимум

Затем значение такой функции умножается на вес - один из параметров
алгоритма, который задается самим пользователем.

## Веса фитнес функции

Необходимо дать пользователю возможность выбрать, что для него важнее:
чтобы друзья сидели вместе, или чтобы те, кто хотят сидеть на первой
парте сидели на первой парте? Поэтому были введены веса: числа от 0 до
1, на которые домножаются значения функций проверки предпочтений. Весов
столько же, сколько и видов предпочтений + 5-й, который влияет на
заполняемость класса (то есть, насколько учеников при рассадке должно
тянуть вперед, к доске)

## Почему выбран язык программирования Go?

Главная причина - производительность и легкость развертывания. По
сравнению с Python Go быстрее в 15-20 раз (зависит от задачи) и вместо
вереницы непонятных файлов в Go один скомпилированный бинарный файл,
который запустится везде без головной боли.

А еще Go в принципе идеален для написания таких микросервисов, ибо для
этого и создавался.

## “Архитектура”

Вычисление алгоритма лежит на отдельном сервере, а не на машине
пользователя. Почему? Потому что в таком случае запускать можно с любого
компьютера. На корректную работу алгоритма не будет влиять мощность
компьютера пользователя, нет требований по установке какого-то
дополнительного программного обеспечения.

Фронтенд в таком случае, то есть сам веб-сайт только отправляет запрос
на сервер и получая его, визуализирует, а затем позволяет удобно
работать с результатами: сохранять и экспортировать в PDF рассадки.

## Дружественный интерфейс…

Стояла задача разработать понятный и удобный интерфейс. Нужно было
отделить возможность сохранять классы, выбирать их в генераторе и
изменять их параметры друг от друга, и еще добавить много других
полезных функций, о которых я сейчас не вспомню, но они точно улучшили
пользовательский опыт!

Перед нами главный экран: на нем можно выбрать класс и загрузить его в
генератор, открыть историю сохраненных рассадок и редактировать его.

–

Перед нами редактор класса. здесь можно вводить все вышеперечисленные
ограничения. Если нажать на значок карты или сердца, то откроется мини
диалоговое окно с визуализацией класса, где тыкая по рядам и партам
можно прописывать ученикам соответственно ряды и парты медицинские и
обычные.

–

Интерфейс генератора. Слайдеры для настройки тех самых весов,
визуализация класса с тепловой картой учтенности предпочтений каждого
ученика.

–

Архив рассадок. И возможность так же открыть визуализацию рассадки в
мини диалоговом окне, а в последствии экспортировать в PDF.

## Что использовано

Различные библиотеки.

```json
{
  "name": "frontend",
  "private": true,
  "version": "0.0.0",
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview"
  },
  "dependencies": {
    "@popperjs/core": "^2.11.8",
    "axios": "^1.13.2", // для отправки запросов к бекенду
    "bootstrap": "^5.3.8", // интерфейс
    "bootstrap-vue-next": "^0.40.9", // интерфейс
    "jspdf": "^4.0.0", // генерация PDF рассадки
    "jspdf-autotable": "^5.0.7",
    "papaparse": "^5.5.3", // импорт/экспорт CSV файлов для классов
    "unplugin-icons": "^22.5.0", // иконки
    "vue": "^3.5.26", // фреймворк
    "vue-router": "^4.6.4", // роутер для многостраничности
    "vuedraggable": "^4.1.0"
  },
  "devDependencies": {
    "@iconify-json/bi": "^1.2.7",
    "@vitejs/plugin-vue": "^6.0.3",
    "unplugin-vue-components": "^29.2.0",
    "vite": "^7.3.1"
  }
}
```

## Структура файлов

Главные здесь те файлы, что заканчиваются на .Vue. Это и есть те самые
компоненты, кусочки, страницы интерфейса. Остальное вторично

- Файлы в папке composables/ содержат всю логику фронтенда

- ClassEditor.vue - редактор класса

- ClassesList.vue - список классов с главного экрана

- ClassMap.vue - визуализатор рядов и парт, вынесен в отдельный
  компонент из-за последующего переиспользования

- Generator.vue - страница самого генератора, что отправляет запросы к
  бекенду

- SeatingHistory.vue - страница, где можно посмотреть все сохраненные
  пользователем рассадки.

Стоит сказать, что все классы и рассадки сохраняются в localStorage
браузера пользователя. Это позволяет пользователю не терять свои данные
при перезагрузке страницы и не только. Если целенаправленно не стирать
историю браузера, выбирая удаление кеша и cookie, то все будет надежно
хранится.

## Почему все запускается одной командой или CI/CD

Была настроена очень удобная система сборки генератора как его отдельных
составных частей, с помощью Docker и GitHub Actions. При любом изменении
файла проекта запускается автоматическая компиляция и сборка. Поэтому в
GHRC всегда лежит свежая версия контейнера. А оттуда пользователь или
сервер может скачать новую версию.

## Всемирная паутина

Был приобретен домен seating-generator.ru и VPS. Это позволило легко (с
учетом автоматизации сборки) разместить сайт генератора в Интернете.
Стоит отметить, что это может сделать любой желающий, что тоже было
достигнуто благодаря сборке и GitHub Actions.

## Лицензирование

Проект лицензирован под GNU Affero General Public License version 3. Что
это значит для проекта:

- любой пользователь всегда будет иметь свободу изменять,
  распространять, неограниченно устанавливать, развертывать,
  использовать и изучать программу

- любое изменение к программе должно быть выпущено с той же самой
  лицензией, что гарантирует свободность программы

- если сервис доступен через Интернет, исходный код обязан быть
  открытым (требования версии Affero)

- пользователь должен иметь право знать, как обрабатываются его данные

А из этого непосредственно следует:

- любой может улучшить генератор

- любой может развернуть свою собственную копию для школы или
  университета
